const progData = [
    {
        "id": "prog1",
        "tema": 1,
        "title": "Ejercicio 1. Aplicación de Metodologías Ágiles para un Proyecto de Comercio Electrónico",
        "scenario": "## Contexto\nUn equipo de desarrollo ha recibido la solicitud de crear una tienda en línea que permita a los usuarios navegar por productos, agregarlos al carrito y realizar compras seguras. El cliente requiere entregas frecuentes para evaluar el progreso y proponer mejoras. \n\n## Tareas\nComo desarrollador: \n- Explica por qué una metodología ágil es adecuada para este proyecto. \n- Identifica las ceremonias principales de Scrum que implementarías y describe sus objetivos. \n- Enumera los roles clave en el equipo y sus responsabilidades.",
        "questions": [
            "Ver solución completa."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Metodología Ágil\nScrum es ideal para este proyecto porque facilita entregas frecuentes y retroalimentación continua, permitiendo ajustes rápidos según las necesidades del cliente. \n\n### 2. Ceremonias\n- **Sprint Planning**: Planificar las tareas para el sprint, priorizando funcionalidades como el carrito de compras. \n- **Daily Stand-Up**: Sincronizar al equipo sobre el progreso y bloqueos. \n- **Sprint Review**: Demostrar el incremento funcional al cliente para recibir retroalimentación. \n- **Retrospectiva**: Analizar qué funcionó y qué mejorar en futuros sprints. \n\n### 3. Roles\n- **Product Owner**: Priorizar el backlog y representar los intereses del cliente. \n- **Scrum Master**: Facilitar el proceso ágil y resolver bloqueos. \n- **Equipo de Desarrollo**: Implementar funcionalidades como el catálogo de productos y la pasarela de pagos. \n\nEste enfoque asegura que el producto evolucione constantemente según las expectativas del cliente."
    },
    {
        "id": "prog2",
        "tema": 1,
        "title": "Ejercicio 2. Análisis de Modelos de Ciclo de Vida para un Proyecto de Gestión Escolar",
        "scenario": "## Contexto\nUna institución educativa desea desarrollar un sistema de gestión escolar que permita gestionar estudiantes, cursos y calificaciones. El sistema debe garantizar la seguridad de los datos, ser accesible en navegadores web y cumplir con regulaciones locales de protección de datos. \n\n## Tareas\nComo parte del equipo de desarrollo, se te pide: \n- Describir las actividades principales de la fase de análisis y diseño en el modelo seleccionado. \n- Justificar tu elección del modelo, destacando ventajas y posibles limitaciones para este caso. \n- Analizar las características del proyecto y seleccionar un modelo de ciclo de vida adecuado (cascada, espiral, incremental o ágil).",
        "questions": [
            "Ver solución completa."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Modelo Seleccionado\nEl modelo en espiral es adecuado, ya que el sistema necesita alta seguridad y cumplimiento normativo. Este modelo permite identificar y gestionar riesgos en cada iteración. \n\n### 2. Justificación\n**Ventajas:**\n- Gestión de riesgos en cada iteración. \n- Flexibilidad para incorporar cambios durante el desarrollo. \n\n**Limitaciones:**\n- Costos más altos debido al análisis continuo. \n- Requiere personal con experiencia en gestión de riesgos. \n\n### 3. Actividades\n- **Análisis**: Identificar requisitos funcionales como la gestión de estudiantes y cursos, y no funcionales como la seguridad y escalabilidad. Realizar entrevistas con los administradores escolares. \n- **Diseño**: Crear diagramas de clases para las entidades principales (estudiantes, cursos). Diseñar un mockup de la interfaz para la gestión de calificaciones."
    },
    {
        "id": "prog3",
        "tema": 2,
        "title": "Ejercicio 3. Aplicación de Metodologías Ágiles y Principios de Desarrollo para un Proyecto de Software Educativo",
        "scenario": "## Contexto\nUna institución educativa desea desarrollar una plataforma web que permita a los estudiantes acceder a recursos educativos, participar en foros de discusión y enviar tareas para revisión.\n\n**Requisitos iniciales:**\n- Registro y autenticación de usuarios. \n- Gestión de contenido por parte de los profesores. \n- Interacción entre estudiantes y profesores mediante foros y mensajería. \n- Función de subida y calificación de tareas. \n\nEl cliente ha pedido entregas frecuentes para evaluar el progreso y ajustar funcionalidades según el feedback recibido. También solicita que el equipo de desarrollo siga estándares de calidad y mantenga el código bien documentado. \n\n## Tareas\n- Proponer una metodología de desarrollo adecuada para este proyecto, justificando su elección. \n- Identificar las buenas prácticas y herramientas que el equipo debería usar para garantizar la calidad del código y la validación temprana. \n- Detallar cómo integrarías las ceremonias de Scrum en el flujo de trabajo del equipo.",
        "questions": [
            "Ver solución completa."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Metodología Propuesta\nPara este proyecto, la metodología **Scrum** es ideal. \n\n**Justificación:**\n- Permite trabajar en incrementos funcionales (por ejemplo, desarrollar primero el registro de usuarios). \n- Facilita adaptarse a los cambios en los requisitos mediante sprints cortos. \n- Promueve la colaboración constante entre el cliente y el equipo. \n\n### 2. Buenas Prácticas y Herramientas\n**Buenas Prácticas:**\n- Aplicar PEP8 para asegurar un código limpio y consistente. \n- Seguir principios como DRY (evitar duplicar código) y KISS (mantener el diseño simple). \n\n**Herramientas:**\n- Linters como pylint y flake8 para detectar errores de estilo y problemas de lógica. \n- Pruebas unitarias con pytest para validar cada funcionalidad desarrollada. \n- Sistemas de integración continua (GitHub Actions) para ejecutar validaciones automáticas al subir cambios al repositorio. \n\n### 3. Integración de Ceremonias Scrum\n- **Sprint Planning**: Antes de cada sprint, definir objetivos claros, como implementar el módulo de foros o la subida de tareas. \n- **Reuniones Diarias**: Breves encuentros para sincronizar al equipo, identificar bloqueos y planificar el día. \n- **Sprint Review**: Mostrar al cliente las funcionalidades completadas y recopilar feedback para priorizar ajustes. \n- **Retrospectiva**: Reflexionar sobre qué funcionó bien y qué debe mejorarse para aumentar la eficiencia del equipo en el siguiente sprint. \n\nEsta solución garantiza un desarrollo ágil, enfocado en la calidad, con entregas frecuentes y alineado con las expectativas del cliente."
    },
    {
        "id": "prog4",
        "tema": 2,
        "title": "Ejercicio 4. Desarrollo de un Sistema de Información para la Gestión de Historias Clínicas Electrónicas",
        "scenario": "## Contexto\nUna institución sanitaria requiere un sistema de información para gestionar las historias clínicas electrónicas (HCE) de sus pacientes. El sistema debe cumplir con estrictas regulaciones legales de protección de datos y seguridad, como la Ley de Protección de Datos Personales.\n\n**Requisitos iniciales:**\n- Registro y acceso seguro a las historias clínicas. \n- Gestión de permisos para diferentes roles médicos. \n- Generación de reportes y auditorías de acceso. \n- Integración con sistemas hospitalarios existentes. \n\nEl cliente exige una planificación detallada, documentación exhaustiva y un proceso riguroso de validación para garantizar que el sistema cumpla con todas las normativas. \n\n## Tareas\n- Justificar por qué el modelo Waterfall es adecuado para este proyecto. \n- Describir las etapas del modelo y cómo se aplicarían al caso. \n- Identificar los beneficios de este enfoque frente a metodologías ágiles.",
        "questions": [
            "Ver solución completa."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Justificación del Modelo Waterfall\nEl modelo Waterfall es ideal para este proyecto debido a la necesidad de cumplir con regulaciones estrictas de protección de datos en el sector sanitario. Su enfoque secuencial y estructurado garantiza que cada fase se complete y verifique antes de avanzar a la siguiente, minimizando riesgos y errores. Además, la generación de documentación exhaustiva es crucial para auditar el cumplimiento normativo y facilitar el mantenimiento del sistema. \n\n### 2. Aplicación de las Etapas del Modelo Waterfall\n- **Recolección de requisitos**: Se identifican y documentan exhaustivamente los requisitos funcionales y no funcionales, incluyendo regulaciones específicas como el control de accesos y la encriptación de datos. \n- **Diseño del sistema**:  \n    - *Diseño conceptual*: Definir la arquitectura del sistema, como bases de datos seguras y módulos de gestión de permisos. \n    - *Diseño detallado*: Especificar estructuras de datos, flujos de trabajo y esquemas de auditoría. \n- **Implementación**: Los desarrolladores traducen el diseño a código funcional utilizando lenguajes seguros como Python y frameworks orientados a sistemas sanitarios. \n- **Pruebas**: Se realizan pruebas exhaustivas, como pruebas de seguridad, para garantizar que el sistema cumpla con las normativas y funcione correctamente. \n- **Despliegue**: El sistema se implementa en el entorno de producción, acompañado de manuales técnicos y capacitación para el personal médico. \n- **Mantenimiento**: Se gestionan actualizaciones para cumplir con nuevas regulaciones y se corrigen errores detectados en producción. \n\n### 3. Beneficios del Enfoque Waterfall\n- **Estabilidad**: Ideal para proyectos con requisitos definidos y poco propensos a cambios. \n- **Cumplimiento normativo**: La documentación detallada facilita auditorías y pruebas regulatorias. \n- **Gestión del riesgo**: El enfoque secuencial asegura un desarrollo controlado, reduciendo errores críticos. \n\nEste enfoque asegura un producto confiable, seguro y alineado con las necesidades del sector regulado."
    },
    {
        "id": "prog5",
        "tema": 3,
        "title": "Ejercicio 5. Gestión de Requisitos para el Desarrollo de un Sistema de Reservas de Consultas Médicas",
        "scenario": "## Contexto\nUna clínica desea desarrollar un sistema de reservas en línea.\n\n**Funcionalidades requeridas:**\n- Registrar una cuenta y autenticarse. \n- Seleccionar un médico y reservar una cita según la disponibilidad. \n- Recibir notificaciones de confirmación y recordatorio por correo electrónico. \n- Consultar su historial de citas. \n\n**Condiciones del sistema:**\n- Proteger los datos de los pacientes según el RGPD. \n- Procesar hasta 500 solicitudes por segundo. \n- Ser accesible desde dispositivos móviles y cumplir con las normas WCAG 2.1. \n\n## Tareas\n- Identifica y clasifica los requisitos funcionales, no funcionales, técnicos y legales del sistema.\n- Proporciona un caso de uso para una funcionalidad clave del sistema.\n- Propuesta de validación: explica cómo validarías los requisitos para asegurar que cumplen con las expectativas del cliente.",
        "questions": [
            "Ver solución completa."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Clasificación de Requisitos\n**Funcionales:**\n- Registro y autenticación de usuarios. \n- Reservar citas con médicos disponibles. \n- Notificar al paciente por correo electrónico. \n\n**No funcionales:**\n- Procesar hasta 500 solicitudes por segundo. \n- Tiempo de respuesta inferior a 2 segundos en redes estándar. \n- Diseño accesible para usuarios con discapacidades (cumplimiento WCAG 2.1). \n\n**Técnicos:**\n- Desarrollar el sistema en Python con Django. \n- Base de datos PostgreSQL para gestionar citas. \n\n**Legales:**\n- Cumplir con el RGPD, implementando anonimización y encriptación de datos. \n\n### 2. Caso de Uso: Reservar una Cita\n**Actor:** Paciente. \n\n**Flujo Principal:**\n1. El paciente inicia sesión. \n2. Selecciona un médico y una fecha disponible. \n3. Confirma la cita y recibe un correo de confirmación. \n\n**Excepciones:**\n- Fecha no disponible o médico seleccionado sin agenda activa. \n\n### 3. Validación\n- **Revisión de requisitos**: Realizar talleres con los stakeholders para confirmar que los requisitos cumplen sus necesidades. \n- **Prototipado**: Crear un prototipo interactivo que permita a los usuarios visualizar el proceso de reserva. \n- **Pruebas automatizadas**: Validar requisitos no funcionales con pruebas de carga para asegurar el rendimiento bajo alta concurrencia."
    },
    {
        "id": "prog6",
        "tema": 3,
        "title": "Ejercicio 6. Sistema de Gestión de Pedidos para una Tienda Online",
        "scenario": "## Contexto\nUna tienda online desea desarrollar un sistema de gestión de pedidos.\n\n**Funcionalidades requeridas:**\n- Registrarse y acceder a su cuenta. \n- Navegar por categorías de productos y añadirlos al carrito. \n- Realizar pagos seguros mediante una pasarela de pago integrada. \n- Recibir confirmación del pedido por correo electrónico. \n\n**Requisitos del sistema:**\n- Procesar hasta 1000 pedidos simultáneos. \n- Cargar la página principal en menos de 2 segundos. \n- Cumplir con el RGPD para garantizar la seguridad de los datos de los clientes. \n\n## Tareas\n- Clasifica los requisitos funcionales, no funcionales, técnicos y legales del sistema. \n- Proporciona un caso de uso para la funcionalidad de realizar un pedido. \n- Explica cómo validarías los requisitos para garantizar que se alineen con las necesidades del cliente.",
        "questions": [
            "Ver solución completa."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Clasificación de Requisitos\n**Funcionales:**\n- Registro y autenticación de clientes. \n- Gestión de carritos de compra. \n- Procesamiento de pagos seguros. \n\n**No funcionales:**\n- Tiempo de carga inferior a 2 segundos. \n- Procesar 1000 pedidos simultáneos. \n\n**Técnicos:**\n- Uso de Python con Django y una base de datos MySQL. \n\n**Legales:**\n- Cumplir con el RGPD mediante encriptación de datos y consentimiento explícito. \n\n### 2. Caso de Uso: Realizar un Pedido\n**Actor:** Cliente. \n\n**Flujo Principal:**\n1. El cliente añade productos al carrito. \n2. Selecciona una dirección de envío y el método de pago. \n3. Realiza el pago y recibe confirmación del pedido. \n\n**Excepciones:**\n- Error en la pasarela de pago o dirección incompleta. \n\n### 3. Validación\n- **Prototipado**: Crear una simulación del flujo de compra para obtener retroalimentación de los stakeholders. \n- **Pruebas de rendimiento**: Evaluar el sistema con herramientas como Apache JMeter para validar la concurrencia."
    },
    {
        "id": "prog7",
        "tema": 4,
        "title": "Ejercicio 7. Creación y Representación de un Modelo Conceptual para un Sistema de Gestión de Reservas en un Restaurante",
        "scenario": "## Contexto\nUn restaurante desea implementar un sistema para gestionar las reservas de sus clientes. El sistema debe permitir:\n- Registrar clientes con su nombre, correo electrónico y número de teléfono.\n- Permitir a los clientes realizar reservas especificando fecha, hora, número de personas y preferencia de mesa.\n- Gestionar la disponibilidad de las mesas, considerando el número de personas.\n- Asignar un empleado (mesero) a las reservas para atenderlas.\n\n## Tareas\n- Identifica las clases principales, atributos y métodos necesarios para el sistema.\n- Crea un diagrama UML que represente las clases y sus relaciones (asociación, composición, herencia).\n- Explica cómo se implementarían las clases y relaciones en Python.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Identificación de Clases, Atributos y Métodos\n\n**Cliente**:\n- Atributos: `idCliente`, `nombre`, `correo`, `telefono`.\n- Métodos: `registrarse()`, `consultarReservas()`.\n\n**Reserva**:\n- Atributos: `idReserva`, `fecha`, `hora`, `numPersonas`, `mesa`, `empleado`.\n- Métodos: `crearReserva()`, `cancelarReserva()`.\n\n**Mesa**:\n- Atributos: `idMesa`, `numAsientos`, `disponible`.\n- Métodos: `actualizarDisponibilidad()`.\n\n**Empleado**:\n- Atributos: `idEmpleado`, `nombre`, `cargo`.\n- Métodos: `asignarReserva()`.\n\n### 2. Diagrama UML\n*(Se recomienda usar una herramienta como Lucidchart o StarUML para visualizar las relaciones)*\n\n### 3. Implementación en Python\n```python\nclass Cliente:\n    def __init__(self, idCliente, nombre, correo, telefono):\n        self.idCliente = idCliente\n        self.nombre = nombre\n        self.correo = correo\n        self.telefono = telefono\n\nclass Mesa:\n    def __init__(self, idMesa, numAsientos, disponible):\n        self.idMesa = idMesa\n        self.numAsientos = numAsientos\n        self.disponible = disponible\n\nclass Reserva:\n    def __init__(self, idReserva, fecha, hora, numPersonas, mesa, empleado):\n        self.idReserva = idReserva\n        self.fecha = fecha\n        self.hora = hora\n        self.numPersonas = numPersonas\n        self.mesa = mesa\n        self.empleado = empleado\n\nclass Empleado:\n    def __init__(self, idEmpleado, nombre, cargo):\n        self.idEmpleado = idEmpleado\n        self.nombre = nombre\n        self.cargo = cargo\n```"
    },
    {
        "id": "prog8",
        "tema": 4,
        "title": "Ejercicio 8. Modelo Conceptual para un Sistema de Gestión de Cursos Online",
        "scenario": "## Contexto\nUna plataforma de educación en línea necesita un sistema para gestionar cursos, instructores y estudiantes. El sistema debe permitir:\n- Registrar estudiantes con su nombre, correo y cursos en los que están inscritos.\n- Permitir a los instructores crear cursos especificando el título, descripción y duración.\n- Gestionar la relación entre estudiantes y cursos, incluyendo la fecha de inscripción y el estado (activo o completado).\n\n## Tareas\n- Identifica las clases principales, atributos y métodos necesarios.\n- Diseña un diagrama UML que represente el sistema.\n- Muestra cómo implementarías las clases y relaciones en Python.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Clases, Atributos y Métodos\n\n**Estudiante**:\n- Atributos: `idEstudiante`, `nombre`, `correo`.\n- Métodos: `registrarse()`, `consultarCursos()`.\n\n**Curso**:\n- Atributos: `idCurso`, `titulo`, `descripcion`, `duracion`.\n- Métodos: `crearCurso()`, `actualizarCurso()`.\n\n**Inscripcion**:\n- Atributos: `idInscripcion`, `fecha`, `estado`.\n- Métodos: `inscribirEstudiante()`, `actualizarEstado()`.\n\n**Instructor**:\n- Atributos: `idInstructor`, `nombre`, `email`.\n- Métodos: `crearCurso()`.\n\n### 2. Diagrama UML\n*(Se recomienda usar una herramienta como Lucidchart o StarUML para visualizar las relaciones)*\n\n### 3. Implementación en Python\n```python\nclass Estudiante:\n    def __init__(self, idEstudiante, nombre, correo):\n        self.idEstudiante = idEstudiante\n        self.nombre = nombre\n        self.correo = correo\n\nclass Curso:\n    def __init__(self, idCurso, titulo, descripcion, duracion):\n        self.idCurso = idCurso\n        self.titulo = titulo\n        self.descripcion = descripcion\n        self.duracion = duracion\n\nclass Inscripcion:\n    def __init__(self, idInscripcion, fecha, estado, estudiante, curso):\n        self.idInscripcion = idInscripcion\n        self.fecha = fecha\n        self.estado = estado\n        self.estudiante = estudiante\n        self.curso = curso\n\nclass Instructor:\n    def __init__(self, idInstructor, nombre, email):\n        self.idInstructor = idInstructor\n        self.nombre = nombre\n        self.email = email\n```"
    },
    {
        "id": "prog9",
        "tema": 5,
        "title": "Ejercicio 9.",
        "scenario": "## Contexto\nUn gimnasio necesita implementar un sistema para gestionar las reservas de clases grupales. El analista propone una estrategia basada en prototipos y mockups para garantizar que la interfaz gráfica (GUI) cumpla con las necesidades de los usuarios. El sistema debe incluir:\n- Una vista de calendario donde los usuarios puedan ver las clases disponibles.\n- Un formulario para registrarse en una clase con datos como nombre del usuario y horario seleccionado.\n- Un área donde los usuarios puedan consultar sus clases reservadas.\n\n## Tareas\n- Describe cómo el analista utilizaría herramientas como Figma o Balsamiq para diseñar un mockup de la interfaz.\n- Propón cómo se implementarían los elementos de la GUI en Python utilizando Tkinter o PyQt.\n- Explica por qué el uso de mockups y prototipos es útil para este proyecto.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Uso de herramientas para mockups\nEn Figma, el analista crea un diseño con tres secciones:\n- El calendario en la parte superior.\n- El formulario de registro en el centro.\n- Las reservas del usuario en la parte inferior.\nUtiliza un diseño limpio y colores que reflejen la identidad del gimnasio.\n\n### 2. Implementación en Python con Tkinter\n- El calendario se representa mediante una tabla interactiva (puede usarse `ttk.Treeview`).\n- Los datos del formulario se capturan con widgets como `Entry` y `Button`.\n- La lista de reservas se muestra en un `Listbox`, donde los usuarios pueden ver o cancelar sus clases.\n\n### 3. Ventajas de prototipos y mockups\n- Facilitan la validación del diseño con los administradores del gimnasio.\n- Permiten realizar ajustes tempranos basados en la retroalimentación antes de iniciar la implementación."
    },
    {
        "id": "prog10",
        "tema": 5,
        "title": "Ejercicio 10.",
        "scenario": "## Contexto\nUna tienda de electrónica desea desarrollar un portal para gestionar las ventas en línea. El analista propone un enfoque iterativo basado en prototipos interactivos para diseñar la interfaz. El portal debe incluir:\n- Una página de productos con filtros (categoría, precio).\n- Un carrito de compras donde los usuarios puedan gestionar sus pedidos.\n- Un formulario para completar la compra con datos de envío y pago.\n\n## Tareas\n- Detalla cómo el analista desarrollaría un prototipo funcional para este proyecto.\n- Explica cómo integrar la interfaz con Python utilizando PyQt.\n- Justifica cómo los prototipos mejoran la comunicación con los stakeholders.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Prototipo funcional\nEn Figma, se crea un prototipo interactivo donde los usuarios puedan simular la selección de productos, añadirlos al carrito y completar la compra. Los filtros se simulan con botones interactivos.\n\n### 2. Implementación en PyQt\n- La lista de productos se implementa con un `QTableWidget`, permitiendo añadir funcionalidades avanzadas como filtros dinámicos.\n- El carrito de compras es un `QListWidget` con opciones para actualizar la cantidad o eliminar productos.\n- El formulario utiliza widgets como `QLineEdit` y `QComboBox` para capturar información de envío y pago.\n\n### 3. Impacto de los prototipos\n- Permiten validar el flujo de navegación y la funcionalidad antes del desarrollo técnico.\n- Ayudan a alinear expectativas entre los stakeholders y el equipo técnico."
    },
    {
        "id": "prog11",
        "tema": 6,
        "title": "Ejercicio 11. Análisis de un Diagrama UML",
        "scenario": "## Contexto\nA continuación, se presenta un diagrama de clases UML que representa una jerarquía de clases en un sistema de gestión de vehículos:\n\n*(Diagrama omitido)*\n\n## Tareas\n- ¿Qué tipo de relación existe entre la clase Vehiculo y las clases Coche y Moto? Justifica tu respuesta.\n- Si se quisiera implementar este modelo en Python, ¿qué palabra clave se utilizaría para establecer la herencia?\n- ¿Cómo aplicarías el polimorfismo en este modelo para que cada tipo de vehículo muestre su propia información al llamar `obtener_info()`?",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Tipo de relación\nLa relación entre `Vehiculo` y sus subclases `Coche` y `Moto` es una relación de **herencia**. En UML, esto se representa con una línea con un triángulo apuntando a la superclase `Vehiculo`, lo que indica que `Coche` y `Moto` heredan sus atributos y métodos.\n\nEsta relación es adecuada porque un `Coche` y una `Moto` son tipos específicos de `Vehiculo` (relación \"es un\"), lo que permite reutilizar atributos comunes (marca, modelo, año) y definir comportamientos compartidos en la superclase.\n\n### 2. Implementación de Herencia en Python\nEn Python, la herencia se establece utilizando la palabra clave `class Subclase(Superclase)`. Para este caso, la implementación básica sería:\n\n```python\nclass Vehiculo:\n    def __init__(self, marca, modelo, año):\n        self.marca = marca\n        self.modelo = modelo\n        self.año = año\n\nclass Coche(Vehiculo):\n    def __init__(self, marca, modelo, año, num_puertas):\n        super().__init__(marca, modelo, año)\n        self.num_puertas = num_puertas\n\nclass Moto(Vehiculo):\n    def __init__(self, marca, modelo, año, cilindrada):\n        super().__init__(marca, modelo, año)\n        self.cilindrada = cilindrada\n```\nLa función `super()` permite llamar al constructor de la clase padre `Vehiculo` y reutilizar su lógica en `Coche` y `Moto`.\n\n### 3. Polimorfismo y `obtener_info()`\nEl polimorfismo permite que `Coche` y `Moto` sobrescriban el método `obtener_info()` de `Vehiculo`, personalizando su comportamiento en cada subclase.\n\nImplementación en Python:\n```python\nclass Vehiculo:\n    def obtener_info(self):\n        return f\"{self.marca} {self.modelo} ({self.año})\"\n\nclass Coche(Vehiculo):\n    def obtener_info(self):\n        return f\"{self.marca} {self.modelo} ({self.año}) - {self.num_puertas} puertas\"\n\nclass Moto(Vehiculo):\n    def obtener_info(self):\n        return f\"{self.marca} {self.modelo} ({self.año}) - {self.cilindrada}cc\"\n\n# Uso del polimorfismo\nvehiculo1 = Coche(\"Toyota\", \"Corolla\", 2022, 4)\nvehiculo2 = Moto(\"Honda\", \"CBR600RR\", 2021, 600)\n\nprint(vehiculo1.obtener_info())  # Toyota Corolla (2022) - 4 puertas\nprint(vehiculo2.obtener_info())  # Honda CBR600RR (2021) - 600cc\n```"
    },
    {
        "id": "prog12",
        "tema": 6,
        "title": "Ejercicio 12. Implementación de una Jerarquía con Herencia y Polimorfismo",
        "scenario": "## Contexto\nImplementa en Python una jerarquía de clases basada en la siguiente estructura:\n- **Clase base**: `Empleado` con atributos `nombre` y `salario`, y un método `calcular_pago()`.\n- **Clases derivadas**:\n    - `Gerente`, cuyo salario incluye un bono del 20%.\n    - `Desarrollador`, cuyo salario incluye un bono del 10%.\n\n## Tareas\n- Escribe el código en Python respetando la herencia y el polimorfismo.\n- Crea instancias de `Gerente` y `Desarrollador`, asignando un salario base de 3000€, e imprime sus respectivos salarios finales.\n- Ejemplo de salida esperada:\n  ```text\n  Gerente: Salario final = 3600€\n  Desarrollador: Salario final = 3300€\n  ```",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Código en Python respetando la herencia y el polimorfismo\nLa implementación en Python debe seguir los principios de la programación orientada a objetos (POO), usando herencia para reutilizar código y polimorfismo para sobrescribir métodos en las subclases.\n\n```python\nclass Empleado:\n    def __init__(self, nombre, salario):\n        self.nombre = nombre\n        self.salario = salario\n\n    def calcular_pago(self):\n        return self.salario  # Método base que será sobrescrito en las subclases\n\nclass Gerente(Empleado):\n    def calcular_pago(self):\n        return self.salario * 1.2  # Bono del 20%\n\nclass Desarrollador(Empleado):\n    def calcular_pago(self):\n        return self.salario * 1.1  # Bono del 10%\n```\nAquí, `Empleado` es la superclase, mientras que `Gerente` y `Desarrollador` heredan de ella y sobrescriben el método `calcular_pago()` para aplicar los bonos correspondientes.\n\n### 2. Creación de instancias y cálculo del salario final\nAhora, creamos instancias de `Gerente` y `Desarrollador` con un salario base de 3000€ y verificamos que el cálculo del salario funcione correctamente.\n\n```python\n# Creación de objetos\nempleado1 = Gerente(\"Laura\", 3000)\nempleado2 = Desarrollador(\"Carlos\", 3000)\n\n# Impresión de salarios finales\nprint(f\"Gerente: Salario final = {empleado1.calcular_pago()}€\")\nprint(f\"Desarrollador: Salario final = {empleado2.calcular_pago()}€\")\n```\nSalida esperada:\n```text\nGerente: Salario final = 3600€\nDesarrollador: Salario final = 3300€\n```"
    },
    {
        "id": "prog13",
        "tema": 7,
        "title": "Ejercicio 13. Implementación de MVC en una Aplicación Web con Flask",
        "scenario": "## Contexto\nUn equipo de desarrollo está construyendo un sistema de gestión de tareas basado en el patrón Model-View-Controller (MVC). Se te ha asignado la tarea de diseñar la estructura del sistema en Flask, asegurando la separación de responsabilidades.\n\n**Objetivo:**\nImplementar una aplicación web sencilla que permita:\n- Agregar nuevas tareas.\n- Ver la lista de tareas registradas.\n- Marcar tareas como completadas.\n\n## Tareas\n- Definir el modelo (`Task`). Debe contener un ID, un nombre de tarea y un estado (pendiente o completado).\n- Implementar el controlador. Debe gestionar las solicitudes de los usuarios y comunicarse con el modelo.\n- Crear la vista. Debe mostrar la lista de tareas y permitir agregar nuevas.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\nPara implementar MVC en Flask, la aplicación se dividirá en tres componentes:\n\n### 1. Modelo (`model.py`) - Gestión de Datos\n```python\ntasks = []  # Simulación de una base de datos en memoria\n\nclass Task:\n    def __init__(self, id, nombre):\n        self.id = id\n        self.nombre = nombre\n        self.estado = \"pendiente\"\n\n    def completar(self):\n        self.estado = \"completado\"\n```\n\n### 2. Controlador (`app.py`) - Lógica de Negocio\n```python\nfrom flask import Flask, render_template, request, redirect\nfrom model import Task, tasks\n\napp = Flask(__name__)\n\n@app.route('/')\ndef mostrar_tareas():\n    return render_template(\"index.html\", tasks=tasks)\n\n@app.route('/agregar', methods=['POST'])\ndef agregar_tarea():\n    nombre = request.form['nombre']\n    nueva_tarea = Task(len(tasks) + 1, nombre)\n    tasks.append(nueva_tarea)\n    return redirect('/')\n\n@app.route('/completar/<int:id>')\ndef completar_tarea(id):\n    for task in tasks:\n        if task.id == id:\n            task.completar()\n    return redirect('/')\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n### 3. Vista (`templates/index.html`) - Presentación\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Gestor de Tareas</title>\n</head>\n<body>\n    <h1>Lista de Tareas</h1>\n    <form action=\"/agregar\" method=\"post\">\n        <input type=\"text\" name=\"nombre\" placeholder=\"Nueva tarea\" required>\n        <button type=\"submit\">Agregar</button>\n    </form>\n    <ul>\n        {% for task in tasks %}\n            <li>{{ task.nombre }} - {{ task.estado }}\n                <a href=\"/completar/{{ task.id }}\">[Marcar como completada]</a>\n            </li>\n        {% endfor %}\n    </ul>\n</body>\n</html>\n```\n\n### Explicación\nEsta implementación sigue la estructura MVC:\n- **Modelo**: Maneja los datos (`Task`).\n- **Vista**: Renderiza la lista de tareas (`index.html`).\n- **Controlador**: Gestiona la lógica de negocio (`app.py`)."
    },
    {
        "id": "prog14",
        "tema": 7,
        "title": "Ejercicio 14. Análisis y Diseño de una Aplicación Web con el Patrón MVC",
        "scenario": "## Contexto\nUna empresa de gestión de eventos desea desarrollar una aplicación web que permita a los usuarios registrarse en eventos, ver la lista de eventos disponibles y gestionar sus inscripciones.\n\nEl equipo de desarrollo ha decidido implementar el patrón Model-View-Controller (MVC) para garantizar una estructura modular y escalable. Como analista del proyecto, tu tarea es diseñar la arquitectura de la aplicación sin necesidad de programar código, identificando cómo se distribuirán las responsabilidades en cada componente de MVC.\n\n## Tareas\n- Definir el Modelo (Model). ¿Qué entidades y atributos deben manejarse en la aplicación?\n- Diseñar la Vista (View). ¿Qué pantallas y elementos visuales necesita el usuario para interactuar con la aplicación?\n- Especificar el Controlador (Controller). ¿Qué lógica de negocio debe implementarse para conectar la vista con el modelo?\n- Explicar cómo la implementación de MVC mejora la organización y mantenimiento del sistema.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\nPara aplicar MVC en esta aplicación, la solución se estructura en los siguientes componentes:\n\n### 1. Modelo (Model) - Gestión de Datos\nEl modelo se encarga de gestionar la información relacionada con los eventos y usuarios. Para este caso, se identifican dos entidades principales:\n- **Usuario**: `id_usuario`, `nombre`, `email`, `eventos_inscritos`.\n- **Evento**: `id_evento`, `nombre_evento`, `fecha`, `capacidad`, `inscritos`.\n\nCada usuario puede registrarse en múltiples eventos, por lo que se debe manejar una relación entre ambas entidades.\n\n### 2. Vista (View) - Interfaz de Usuario\nLa vista es la interfaz con la que interactúan los usuarios. Debe contener las siguientes pantallas:\n- **Página de inicio**: Muestra los eventos disponibles.\n- **Página de registro**: Permite a los usuarios inscribirse en eventos.\n- **Panel de usuario**: Lista los eventos en los que el usuario está inscrito.\n- **Vista de administración**: Permite a los organizadores gestionar los eventos.\n\nLos elementos visuales clave incluyen:\n- Formularios para inscripción.\n- Listados de eventos con capacidad y número de inscritos.\n- Botones de acción (Registrar, Cancelar inscripción).\n\n### 3. Controlador (Controller) - Lógica de Negocio\nEl controlador gestiona la comunicación entre la vista y el modelo, ejecutando la lógica de negocio. Las funciones clave incluyen:\n- **Registrar usuario en un evento**:\n    - Validar que el usuario no esté inscrito previamente.\n    - Verificar que el evento tenga plazas disponibles.\n    - Guardar la inscripción en la base de datos.\n- **Mostrar eventos disponibles**:\n    - Obtener eventos desde el modelo y enviarlos a la vista.\n- **Cancelar inscripción de un usuario**:\n    - Eliminar la relación entre el usuario y el evento en la base de datos.\n\n### 4. Beneficios de Usar MVC en Este Proyecto\nEl uso del patrón MVC en esta aplicación ofrece múltiples ventajas:\n- **Separación de responsabilidades**: Los datos (Model), la interfaz (View) y la lógica de negocio (Controller) están claramente diferenciados.\n- **Mantenibilidad**: Se pueden actualizar o agregar nuevas funcionalidades sin afectar toda la aplicación.\n- **Escalabilidad**: Si la aplicación crece, se pueden integrar nuevas vistas o modelos sin modificar el controlador principal.\n- **Reutilización**: Los componentes del modelo pueden ser reutilizados en diferentes partes del sistema."
    },
    {
        "id": "prog15",
        "tema": 8,
        "title": "Ejercicio 15. Diseño de una API REST para un Sistema de Reservas de Hoteles",
        "scenario": "## Contexto\nUna cadena hotelera necesita desarrollar una API REST que permita a los clientes realizar reservas en sus hoteles de forma eficiente. El equipo de desarrollo ha decidido diseñar la API utilizando Flask o Django REST Framework (DRF) y gestionar los datos con una base de datos SQL. Además, la API deberá incluir funcionalidades para la exportación y análisis de datos mediante pandas.\n\n## Tareas\n- **Diseñar la estructura de la API**:\n    - Identificar los recursos principales que se gestionarán (habitaciones, reservas, clientes).\n    - Definir los endpoints y métodos HTTP necesarios.\n    - Determinar la base de datos a utilizar y si se aplicará un ORM.\n- **Definir el modelo de datos**:\n    - ¿Qué tablas y relaciones serán necesarias para almacenar reservas y disponibilidad de habitaciones?\n    - ¿Cómo se garantizará la consistencia y escalabilidad del sistema?\n- **Exportación y análisis de datos con pandas**:\n    - ¿Qué métricas podrían analizarse a partir de los datos de la API?\n    - ¿En qué formatos deberían exportarse los datos para su análisis (CSV, JSON, Excel)?\n- **Argumentar cómo se manejarán los siguientes aspectos**:\n    - Seguridad y autenticación de la API.\n    - Manejo de errores y validación de datos.\n    - Pruebas y documentación de la API.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Diseño de la API y Endpoints\nPara este sistema de reservas, se identifican los siguientes recursos y endpoints clave:\n\n**Clientes:**\n- `POST /clientes` → Registrar un cliente.\n- `GET /clientes/{id}` → Obtener información de un cliente.\n\n**Habitaciones:**\n- `GET /habitaciones` → Listar habitaciones disponibles.\n- `PUT /habitaciones/{id}` → Modificar disponibilidad de una habitación.\n\n**Reservas:**\n- `POST /reservas` → Crear una reserva.\n- `GET /reservas/{id}` → Consultar detalles de una reserva.\n- `DELETE /reservas/{id}` → Cancelar una reserva.\n\nSe utilizará **Flask con SQLAlchemy** o **Django ORM** para gestionar la base de datos relacional.\n\n### 2. Modelo de Datos\n- **Tabla clientes**: `id`, `nombre`, `email`, `teléfono`.\n- **Tabla habitaciones**: `id`, `tipo`, `precio`, `estado`.\n- **Tabla reservas**: `id`, `cliente_id`, `habitacion_id`, `fecha_checkin`, `fecha_checkout`.\n\nLas relaciones uno a muchos entre clientes y reservas aseguran que cada cliente pueda realizar múltiples reservas.\n\n### 3. Análisis y Exportación de Datos con pandas\nLa API deberá incluir la opción de exportar datos en CSV y JSON para su análisis. Las métricas clave incluyen:\n- **Tasa de ocupación** → % de habitaciones reservadas en un período.\n- **Ingresos por habitación** → Promedio de ingresos generados por cada tipo de habitación.\n- **Reservas canceladas** → Análisis de cancelaciones por temporada.\n\nEstos datos podrán analizarse con pandas para generar reportes útiles en la toma de decisiones.\n\n### 4. Seguridad y Documentación\n- **Autenticación**: Se implementará JWT (JSON Web Tokens) para restringir el acceso a usuarios autenticados.\n- **Validación de datos**: Se usarán esquemas de validación para evitar registros incorrectos.\n- **Documentación**: Se generará con Swagger para facilitar el uso de la API por parte de desarrolladores externos.\n\nEl diseño propuesto permite una gestión eficiente de reservas hoteleras mediante una API REST estructurada, asegurando seguridad, escalabilidad y exportación de datos. Con esta arquitectura, la cadena hotelera podrá optimizar su servicio y tomar decisiones basadas en análisis de datos en tiempo real."
    },
    {
        "id": "prog16",
        "tema": 8,
        "title": "Ejercicio 16. Diseño de una API REST para un Sistema de Gestión de Inventarios en un Almacén",
        "scenario": "## Contexto\nUna empresa de logística necesita una API REST para gestionar su inventario de productos en múltiples almacenes. El equipo de desarrollo ha decidido diseñar la API utilizando Flask o Django REST Framework (DRF) con una base de datos SQL. Además, la API deberá ofrecer opciones de exportación de datos en CSV y JSON para su posterior análisis mediante pandas.\n\n## Tareas\n- **Diseñar la estructura de la API**:\n    - Identificar los recursos principales a gestionar (productos, almacenes, stock).\n    - Definir los endpoints y métodos HTTP.\n    - Seleccionar la base de datos y el ORM adecuado.\n- **Definir el modelo de datos**:\n    - Diseñar las tablas necesarias y sus relaciones.\n    - Asegurar que los datos sean consistentes y escalables.\n- **Exportación y análisis de datos con pandas**:\n    - ¿Qué métricas deberían analizarse (inventario disponible, productos más vendidos, etc.)?\n    - ¿En qué formatos deben exportarse los datos?\n- **Argumentar las estrategias de seguridad, validación de datos y documentación de la API.**",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Diseño de la API y Endpoints\n- **Productos**:\n    - `GET /productos` → Listar productos.\n    - `POST /productos` → Agregar un nuevo producto.\n    - `PUT /productos/{id}` → Modificar información del producto.\n- **Almacenes**:\n    - `GET /almacenes` → Listar almacenes.\n    - `POST /almacenes` → Agregar un nuevo almacén.\n- **Stock**:\n    - `GET /stock/{id_almacen}` → Consultar el stock de un almacén.\n    - `POST /stock` → Agregar existencias de productos.\n\nSe utilizará **Flask con SQLAlchemy** o **Django ORM** para gestionar la base de datos relacional.\n\n### 2. Modelo de Datos\n- **Tabla productos**: `id`, `nombre`, `categoria`, `precio`.\n- **Tabla almacenes**: `id`, `ubicación`, `capacidad`.\n- **Tabla stock**: `id`, `producto_id`, `almacen_id`, `cantidad`.\n\n### 3. Exportación y Análisis de Datos con pandas\n- **Exportar stock** en CSV y JSON.\n- **Métricas a analizar**:\n    - Productos con mayor y menor rotación.\n    - Inventario promedio por almacén.\n\n### 4. Seguridad y Documentación\n- **Autenticación**: JWT.\n- **Validación de datos** en endpoints.\n- **Documentación**: Swagger para documentar la API.\n\nEste diseño permitirá gestionar inventarios eficientemente y optimizar el análisis de stock."
    },
    {
        "id": "prog17",
        "tema": 9,
        "title": "Ejercicio 17. Diseño de una Arquitectura para la Gestión de APIs con un API Manager",
        "scenario": "## Contexto\nUna empresa de comercio electrónico ha decidido modernizar su infraestructura tecnológica mediante la implementación de un API Manager. Actualmente, su plataforma cuenta con múltiples APIs que manejan operaciones clave, como:\n- Gestión de productos (altas, bajas y modificaciones en el catálogo).\n- Procesamiento de pagos (integración con pasarelas de pago como Stripe y PayPal).\n- Gestión de pedidos (creación, seguimiento y cancelaciones).\n\nEl equipo de arquitectura necesita diseñar una solución que incluya un API Manager para mejorar la seguridad, escalabilidad y eficiencia del sistema.\n\n## Tareas\n- **Elección del API Manager**: ¿Qué solución recomendarías (AWS API Gateway, Kong, Apigee, Tyk) y por qué?\n- **Control de seguridad**: ¿Qué mecanismos de autenticación y autorización se implementarán para proteger las APIs?\n- **Gestión del tráfico y monitoreo**: ¿Cómo se asegurará la disponibilidad de la API ante una alta demanda?\n- **Integración con servicios externos**: ¿Cómo se gestionarán las conexiones con terceros (pasarelas de pago, servicios de notificación)?",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Elección del API Manager\nSe recomienda utilizar **Kong API Gateway**, ya que ofrece alta escalabilidad, soporte para contenedores en Kubernetes y flexibilidad con plugins. Alternativamente, AWS API Gateway podría ser una opción si la empresa ya opera en el ecosistema de AWS.\n\n**Razones para elegir Kong API Gateway:**\n- Se integra fácilmente con Docker y Kubernetes, permitiendo despliegues dinámicos.\n- Soporta autenticación mediante OAuth2, JWT y API Keys.\n- Ofrece monitorización avanzada con Prometheus y Grafana.\n\n### 2. Control de Seguridad\nPara proteger las APIs, se implementarán:\n- **Autenticación con OAuth2 y JWT**: Los clientes deberán obtener un token antes de acceder a los recursos.\n- **Autorización basada en roles (RBAC)**: Los administradores podrán modificar datos, mientras que los clientes solo podrán leer información.\n- **Rate Limiting**: Se establecerá un límite de 100 solicitudes por minuto para evitar abusos.\n\n### 3. Gestión del Tráfico y Monitoreo\nPara garantizar la estabilidad de la API:\n- Se implementará caché de respuestas en el API Gateway para reducir la carga en la base de datos.\n- Se utilizarán balanceadores de carga para distribuir el tráfico entre múltiples servidores.\n- Se activarán métricas de rendimiento en Kong con Prometheus y Grafana.\n\n### 4. Integración con Servicios Externos\n- **Pagos con Stripe y PayPal**: Se crearán conectores API dentro del API Manager para gestionar las transacciones de forma segura.\n- **Notificaciones con Twilio o Firebase**: Se implementarán webhooks para notificar a los clientes sobre el estado de sus pedidos en tiempo real.\n\nLa implementación de Kong API Gateway mejorará la seguridad, escalabilidad y eficiencia del ecosistema de APIs de la empresa. Con medidas de autenticación, control de tráfico y conectores externos, se garantizará un servicio seguro y confiable para los clientes."
    },
    {
        "id": "prog18",
        "tema": 9,
        "title": "Ejercicio 18. Diseño de una Arquitectura de API Manager para un Sistema de Salud",
        "scenario": "## Contexto\nUn hospital privado ha decidido modernizar su sistema de gestión médica mediante la implementación de un API Manager. Actualmente, el hospital maneja múltiples servicios en su plataforma digital, incluyendo:\n- Gestión de pacientes (registro, historial clínico, citas médicas).\n- Conexión con laboratorios externos para compartir resultados de análisis.\n- Sistema de facturación que integra pagos con aseguradoras y pasarelas de pago.\n\nEl equipo de TI debe diseñar una solución con un API Manager para garantizar la seguridad de los datos médicos, la integración con terceros y el monitoreo del sistema.\n\n## Tareas\n- **Elección del API Manager**: ¿Qué solución recomendarías (Apigee, AWS API Gateway, Kong, Tyk) y por qué?\n- **Control de seguridad**: ¿Cómo se garantizará la protección de datos médicos y el cumplimiento de normativas como HIPAA o GDPR?\n- **Gestión del tráfico y monitoreo**: ¿Cómo se asegurará la disponibilidad del sistema ante una alta demanda?\n- **Integración con laboratorios y aseguradoras**: ¿Cómo se gestionarán estas conexiones externas de manera segura y eficiente?",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Elección del API Manager\nSe recomienda **Apigee (Google Cloud)** debido a su enfoque en seguridad y cumplimiento normativo, con soporte para OAuth2, autenticación basada en roles (RBAC) y registros de auditoría.\n\n### 2. Control de Seguridad\n- **Autenticación con OAuth2 y JWT** para garantizar que solo usuarios autorizados accedan a los datos.\n- **Cifrado de datos en tránsito** con HTTPS y TLS 1.2+.\n- **Reglas de acceso RBAC** para definir qué usuarios pueden acceder a información específica.\n\n### 3. Gestión del Tráfico y Monitoreo\n- **Rate Limiting**: Se limita el acceso a 50 solicitudes por minuto por usuario para evitar abusos.\n- **Alta disponibilidad y balanceo de carga**: Se distribuye el tráfico entre múltiples servidores.\n- **Monitoreo en tiempo real** con Grafana y Prometheus.\n\n### 4. Integración con Terceros\n- **Interoperabilidad con laboratorios**: Uso de FHIR (*Fast Healthcare Interoperability Resources*) para estandarizar el intercambio de datos médicos.\n- **Conexión con aseguradoras**: Implementación de webhooks y API Gateway para validar pagos y seguros en tiempo real.\n\nCon esta solución, el hospital garantiza un sistema seguro, escalable y compatible con regulaciones médicas, optimizando la experiencia de médicos y pacientes."
    },
    {
        "id": "prog19",
        "tema": 10,
        "title": "Ejercicio 19. Estrategia de Testing para una Plataforma de Comercio Electrónico",
        "scenario": "## Contexto\nUna empresa de comercio electrónico está desarrollando una nueva versión de su plataforma web, que incluye las siguientes funcionalidades clave:\n- Gestión de usuarios: Registro, inicio de sesión y recuperación de contraseñas.\n- Catálogo de productos: Visualización, filtrado y búsqueda de productos.\n- Carrito de compras y pagos: Agregar productos al carrito, procesar pagos con Stripe y PayPal.\n- Sistema de pedidos: Seguimiento y notificación de envíos.\n\nEl equipo de desarrollo ha solicitado definir una estrategia de pruebas para garantizar la calidad del software antes de su lanzamiento.\n\n## Tareas\n- **Definir los tipos de pruebas necesarias** (unitarias, integración, sistema, aceptación).\n- **Planificar pruebas no funcionales** (rendimiento, seguridad, usabilidad).\n- **Seleccionar herramientas adecuadas** para la ejecución de pruebas automatizadas y manuales.\n- **Establecer un proceso de reporte y seguimiento de errores**.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Definir los Tipos de Pruebas Necesarias\nPara asegurar la calidad del software, se implementarán las siguientes pruebas:\n- **Pruebas unitarias**: Validar que los módulos individuales funcionan correctamente (Ejemplo: función de validación de contraseñas).\n- **Pruebas de integración**: Verificar que los módulos interactúan sin errores (Ejemplo: integración entre carrito de compras y sistema de pago).\n- **Pruebas de sistema**: Evaluar la funcionalidad global de la plataforma (Ejemplo: flujo de compra completo).\n- **Pruebas de aceptación**: Realizar pruebas con usuarios finales para validar la experiencia del cliente.\n\n### 2. Planificación de Pruebas No Funcionales\n- **Pruebas de rendimiento**: Simulación de múltiples usuarios concurrentes para medir tiempos de respuesta con JMeter.\n- **Pruebas de seguridad**: Uso de OWASP ZAP para detectar vulnerabilidades como inyección SQL o fallos en autenticación.\n- **Pruebas de usabilidad**: Evaluación con usuarios para optimizar la experiencia de compra y navegación.\n\n### 3. Selección de Herramientas\n- **Selenium** para pruebas automatizadas en la interfaz gráfica.\n- **Postman** para pruebas en APIs REST.\n- **GitHub Actions** para integración de pruebas en CI/CD y ejecución automática en cada commit.\n\n### 4. Proceso de Reporte y Seguimiento de Errores\n- Uso de **JIRA** o **Trello** para registrar defectos detectados.\n- Clasificación de errores por severidad y prioridad.\n- Revisión periódica de métricas de calidad y tasa de resolución de errores.\n\nImplementar una estrategia de testing integral permitirá detectar errores antes del despliegue, optimizar el rendimiento y mejorar la seguridad de la plataforma. Con el uso de herramientas automatizadas y pruebas manuales, la empresa garantizará una experiencia de compra estable y segura para sus clientes."
    },
    {
        "id": "prog20",
        "tema": 10,
        "title": "Ejercicio 20. Estrategia de Testing para una Aplicación de Reservas de Hoteles",
        "scenario": "## Contexto\nUna empresa de turismo ha desarrollado una aplicación web y móvil para gestionar reservas de hoteles, donde los usuarios pueden:\n- Buscar hoteles según ubicación, disponibilidad y precio.\n- Reservar habitaciones y pagar en línea con tarjetas de crédito y PayPal.\n- Gestionar cancelaciones y modificaciones de reservas.\n- Recibir confirmaciones y notificaciones de su reserva.\n\nEl equipo de desarrollo necesita definir una estrategia de testing antes del lanzamiento para garantizar que el sistema sea estable, seguro y fácil de usar.\n\n## Tareas\n- **Definir los tipos de pruebas necesarias** (unitarias, integración, sistema, aceptación).\n- **Planificar pruebas no funcionales** (rendimiento, seguridad, compatibilidad).\n- **Seleccionar herramientas adecuadas** para la ejecución de pruebas automatizadas y manuales.\n- **Establecer un proceso de reporte y seguimiento de errores**.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Tipos de Pruebas Necesarias\n- **Pruebas unitarias**: Evaluar funciones críticas como el cálculo de disponibilidad y el procesamiento de pagos.\n- **Pruebas de integración**: Asegurar la correcta conexión entre la API de reservas, el sistema de pagos y la base de datos.\n- **Pruebas de sistema**: Verificar el flujo de búsqueda, reserva y confirmación de habitaciones.\n- **Pruebas de aceptación**: Incluir usuarios reales para probar la experiencia de reserva antes del lanzamiento.\n\n### 2. Pruebas No Funcionales\n- **Pruebas de rendimiento**: Medir tiempos de carga en horarios pico usando JMeter.\n- **Pruebas de seguridad**: Detectar vulnerabilidades con OWASP ZAP, asegurando que los pagos sean seguros.\n- **Pruebas de compatibilidad**: Verificar el funcionamiento en navegadores web (Chrome, Firefox, Safari) y dispositivos móviles (Android, iOS).\n\n### 3. Herramientas Seleccionadas\n- **Selenium** para pruebas automatizadas en la interfaz web.\n- **Postman** para validar las API REST de búsqueda y reservas.\n- **GitLab CI/CD** para integrar pruebas automatizadas en el proceso de desarrollo.\n\n### 4. Proceso de Reporte de Errores\n- Uso de **JIRA** para registrar y clasificar errores según prioridad.\n- Asignación de responsables para corregir defectos y realizar nuevas pruebas antes del despliegue.\n\nEste enfoque de testing permitirá detectar fallos antes del lanzamiento y garantizar que la aplicación de reservas funcione correctamente en todos los dispositivos y condiciones."
    },
    {
        "id": "prog21",
        "tema": 11,
        "title": "Ejercicio 21. Validación de una Aplicación Multiplataforma para Reservas de Viajes",
        "scenario": "## Contexto\nUna agencia de viajes ha desarrollado una aplicación multiplataforma que permite a los usuarios:\n- Buscar y reservar vuelos y hoteles desde dispositivos móviles (Android/iOS) y navegadores web.\n- Realizar pagos en línea a través de tarjetas de crédito y plataformas como PayPal.\n- Recibir notificaciones sobre cambios en sus reservas.\n- Acceder a sus itinerarios sin conexión mediante almacenamiento en caché.\n\nEl equipo de desarrollo necesita garantizar que la aplicación funcione correctamente en distintos dispositivos, sistemas operativos y navegadores. Para ello, han solicitado una estrategia de validación multiplataforma.\n\n## Tareas\n- **Definir las pruebas de compatibilidad necesarias** en web y dispositivos móviles.\n- **Planificar el uso de emuladores y pruebas en dispositivos reales**.\n- **Determinar herramientas y metodologías** para evaluar rendimiento y consumo de recursos.\n- **Implementar pruebas automatizadas** con Appium o Selenium.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Pruebas de Compatibilidad en Web y Móvil\n- **Pruebas en navegadores**: Validar el funcionamiento en Chrome, Firefox, Safari y Edge para asegurar que los elementos gráficos y formularios sean consistentes.\n- **Pruebas en dispositivos móviles**: Evaluar la interfaz y experiencia de usuario en Android (Samsung, Xiaomi, Google Pixel) y iOS (iPhone, iPad).\n- **Pruebas de resolución y diseño responsivo**: Utilizar Google Lighthouse para evaluar la adaptación del diseño en diferentes tamaños de pantalla.\n\n### 2. Uso de Emuladores y Pruebas en Dispositivos Reales\n- **Emuladores**: Android Studio Emulator y Xcode Simulator para simular la aplicación en distintos modelos sin necesidad de hardware físico.\n- **Dispositivos reales**: Probar la aplicación en smartphones y tablets para detectar diferencias en rendimiento y comportamiento de los sensores (GPS, cámara).\n\n### 3. Evaluación de Rendimiento y Consumo de Recursos\n- **Tiempo de carga y respuesta**: Medir con herramientas como JMeter y Firebase Performance Monitoring.\n- **Consumo de batería y memoria**: Evaluar en dispositivos reales con Android Profiler y Xcode Instruments.\n\n### 4. Pruebas Automatizadas con Appium y Selenium\n- **Automatizar pruebas de UI en la web con Selenium** para validar el flujo de reservas en diferentes navegadores.\n- **Automatizar pruebas móviles con Appium** para simular toques, deslizamientos y validación de formularios.\n\nEsta estrategia garantiza que la aplicación de reservas sea compatible, rápida y accesible en múltiples plataformas. Con pruebas en emuladores, dispositivos reales y herramientas de automatización, se mejora la experiencia del usuario y se previenen errores antes del lanzamiento."
    },
    {
        "id": "prog22",
        "tema": 11,
        "title": "Ejercicio 22. Validación Multiplataforma de una Aplicación de Comercio Electrónico",
        "scenario": "## Contexto\nUna empresa de comercio electrónico ha desarrollado una aplicación web y móvil para que los usuarios puedan:\n- Explorar y comprar productos desde cualquier dispositivo.\n- Realizar pagos en línea con distintos métodos como PayPal, tarjetas de crédito y Google Pay.\n- Acceder a su historial de compras y gestionar devoluciones.\n- Recibir notificaciones sobre ofertas y promociones en tiempo real.\n\nEl equipo de desarrollo necesita definir una estrategia de validación multiplataforma para garantizar que la aplicación funcione correctamente en distintos dispositivos y navegadores.\n\n## Tareas\n- **Definir pruebas de compatibilidad** en navegadores y sistemas operativos móviles.\n- **Establecer una estrategia para evaluar rendimiento y usabilidad** en distintos dispositivos.\n- **Seleccionar herramientas para pruebas automatizadas** en web y móvil.\n- **Garantizar la seguridad en las transacciones y almacenamiento de datos**.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n\n### 1. Pruebas de Compatibilidad en Diferentes Dispositivos\n- **Web**: Validación en Chrome, Firefox, Safari y Edge para asegurar que la tienda online se visualice correctamente.\n- **Móvil**: Pruebas en dispositivos con Android e iOS para verificar la navegación y experiencia del usuario en pantallas táctiles.\n- **Pruebas de accesibilidad**: Uso de Google Lighthouse y WAVE para evaluar que la interfaz sea accesible para personas con discapacidades visuales.\n\n### 2. Evaluación de Rendimiento y Usabilidad\n- **Tiempo de carga**: Medición con JMeter y Google PageSpeed Insights.\n- **Optimización de recursos**: Minimización de imágenes y reducción de consultas a la base de datos para mejorar el rendimiento.\n- **Pruebas con usuarios reales**: Evaluación de usabilidad mediante encuestas y pruebas A/B.\n\n### 3. Pruebas Automatizadas en Web y Móvil\n- **Selenium**: Para validar el flujo de compra en la tienda online en distintos navegadores.\n- **Appium**: Para simular interacciones de usuario en la aplicación móvil.\n\n### 4. Seguridad en Transacciones\n- **Encriptación de datos** con HTTPS y TLS para proteger pagos en línea.\n- **Pruebas de seguridad** con OWASP ZAP para detectar vulnerabilidades en autenticación y almacenamiento de información.\n\nImplementar esta estrategia de validación permitirá garantizar la compatibilidad, rendimiento y seguridad de la tienda online, asegurando una experiencia de compra fluida y sin errores."
    },
    {
        "id": "prog23",
        "tema": 12,
        "title": "Ejercicio 23. Empaquetado y Despliegue de una Aplicación Web en la Nube",
        "scenario": "## Contexto\nUna empresa de tecnología ha desarrollado una aplicación web en Python con Flask que permite a los usuarios administrar sus tareas diarias. La aplicación incluye autenticación de usuarios, almacenamiento en bases de datos y una API REST para gestionar las tareas.\n\nEl equipo de desarrollo necesita preparar la aplicación para su distribución y despliegue en la nube, asegurando que sea fácil de instalar, escalar y actualizar.\n\n## Tareas\n- **Empaquetar la aplicación** en un paquete Python utilizando setuptools y generar un ejecutable con PyInstaller.\n- **Configurar Docker** para contenerizar la aplicación y facilitar su despliegue en cualquier entorno.\n- **Desplegar la aplicación** en Heroku o AWS Elastic Beanstalk para que sea accesible desde internet.\n- **Gestionar las versiones del software** usando GitFlow y crear una release documentada con un changelog en GitHub Releases.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n### 1. Empaquetado de la Aplicación\n\nPara distribuir la aplicación, se configura `setup.py` en la raíz del proyecto:\n\n```python\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"gestor_tareas\",\n    version=\"1.0.0\",\n    packages=find_packages(),\n    install_requires=[\"Flask\", \"SQLAlchemy\"],\n    entry_points={\"console_scripts\": [\"gestor_tareas=app:main\"]},\n)\n```\n\nLuego, se crea un ejecutable con PyInstaller:\n\n```bash\npyinstaller --onefile --name gestor_tareas app.py\n```\n\nEsto genera un archivo ejecutable en la carpeta `dist/`.\n\n### 2. Configuración de Docker\n\nSe crea un `Dockerfile` para la aplicación:\n\n```dockerfile\nFROM python:3.9\n\nWORKDIR /app\n\nCOPY . /app\n\nRUN pip install -r requirements.txt\n\nEXPOSE 5000\n\nCMD [\"python\", \"app.py\"]\n```\n\nPara construir y ejecutar la imagen Docker:\n\n```bash\ndocker build -t gestor_tareas .\ndocker run -p 5000:5000 gestor_tareas\n```\n\n### 3. Despliegue en la Nube (Heroku o AWS Elastic Beanstalk)\n\nPara desplegar en Heroku:\n\n```bash\nheroku login\nheroku create gestor-tareas\ngit push heroku main\nheroku open\n```\n\nPara desplegar en AWS Elastic Beanstalk:\n\n```bash\neb init -p python-3.9 gestor-tareas\neb create gestor-tareas-env\n```\n\n### 4. Gestión de Versiones y Releases\n\nSe utiliza GitFlow para gestionar ramas:\n\n```bash\ngit flow init\ngit flow release start v1.0.0\ngit flow release finish v1.0.0\n```\n\nLuego, se crea una release en GitHub Releases, adjuntando un changelog con las nuevas funcionalidades.\n\nSiguiendo estos pasos, la aplicación estará lista para ser instalada, desplegada y mantenida en producción con una estrategia clara de empaquetado, despliegue y versionado."
    },
    {
        "id": "prog24",
        "tema": 12,
        "title": "Ejercicio 24. Empaquetado y Despliegue de una API REST en AWS",
        "scenario": "## Contexto\nUn equipo de desarrollo ha creado una API REST en Flask que permite a los usuarios gestionar sus notas personales. La API incluye autenticación con JWT, almacenamiento en PostgreSQL y endpoints para crear, editar y eliminar notas.\n\nEl equipo necesita empaquetar, desplegar y gestionar versiones de la API de manera eficiente, asegurando que sea escalable y fácil de mantener.\n\n## Tareas\n- **Empaquetar la API** como un paquete instalable en Python usando setuptools.\n- **Configurar un contenedor Docker** para facilitar su despliegue en diferentes entornos.\n- **Implementar el despliegue en AWS Elastic Beanstalk** con una base de datos PostgreSQL en RDS.\n- **Gestionar el versionado** con SemVer y GitFlow, publicando releases en GitHub.",
        "questions": [
            "Ver escenario completo."
        ],
        "answer": "## Solución Propuesta\n### 1. Empaquetado con setuptools\n\nSe crea un archivo `setup.py` para definir la instalación del paquete:\n\n```python\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"api_notas\",\n    version=\"1.0.0\",\n    packages=find_packages(),\n    install_requires=[\"Flask\", \"Flask-JWT-Extended\", \"SQLAlchemy\"],\n    entry_points={\"console_scripts\": [\"api_notas=app:main\"]},\n)\n```\n\nLuego, se genera el paquete:\n\n```bash\npython setup.py sdist bdist_wheel\n```\n\n### 2. Configuración de Docker\n\nSe crea un `Dockerfile`:\n\n```dockerfile\nFROM python:3.9\n\nWORKDIR /app\n\nCOPY . /app\n\nRUN pip install -r requirements.txt\n\nEXPOSE 5000\n\nCMD [\"python\", \"app.py\"]\n```\n\nSe construye y ejecuta la imagen Docker:\n\n```bash\ndocker build -t api_notas .\ndocker run -p 5000:5000 api_notas\n```\n\n### 3. Despliegue en AWS Elastic Beanstalk\n\n```bash\neb init -p python-3.9 api-notas\neb create api-notas-env\n```\n\nPara configurar la base de datos en AWS RDS, se establece la conexión en `config.py` con las credenciales del servicio.\n\n### 4. Gestión de Versiones y Releases\n\nSe utiliza GitFlow para administrar versiones:\n\n```bash\ngit flow release start v1.0.0\ngit flow release finish v1.0.0\n```\n\nFinalmente, se publica en GitHub Releases con un changelog documentado.\n\nEsta estrategia garantiza que la API REST sea portátil, escalable y segura, facilitando su mantenimiento en AWS."
    }
];